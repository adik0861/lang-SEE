import { LRParser } from '@lezer/lr';
import { styleTags, tags } from '@lezer/highlight';
import { indentNodeProp, foldNodeProp, foldInside, LRLanguage, LanguageSupport } from '@codemirror/language';
import { completeFromList } from '@codemirror/autocomplete';

const jsonHighlighting = styleTags({
  String: tags.string,
  Number: tags.number,
  "True False": tags.bool,
  PropertyName: tags.propertyName,
  Null: tags.null,
  ",": tags.separator,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace,
  Keyword: tags.keyword,
  Bool: tags.bool,

});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
  version: 14,
  states: "$bOYQPOOOOQO'#Cc'#CcOwQPO'#CfO!PQPO'#CkOOQO'#Cs'#CsQOQPOOOOQO'#Ch'#ChO!WQPO'#CgO!]QPO'#CuOOQO,59Q,59QO!eQPO,59QO!jQPO'#CxOOQO,59V,59VO!rQPO,59VOYQPO,59ROzQPO'#CnO!wQPO,59aOOQO1G.l1G.lOYQPO'#CoO#PQPO,59dOOQO1G.q1G.qOOQO1G.m1G.mOOQO,59Y,59YOOQO-E6l-E6lOOQO,59Z,59ZOOQO-E6m-E6m",
  stateData: "#X~OfOSPOS~ORSOSSOTSOUSOXQO^RO`SOaSOhPO~OWXOhUO~O][O~PYOj^O~Ok_OWiX~OWaO~OkbO]lX~O]dO~Ok_OWia~OkbO]la~O",
  goto: "!nmPPPPPPPnPPntzPPnPP!O!UPPP![P!hPP!kXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "âš  Comment JsonText True False Null Number String } { Object Property PropertyName ] [ Array Keyword Bool",
  maxTerm: 28,
  nodeProps: [
    ["openedBy", 8,"{",13,"["],
    ["closedBy", 9,"}",14,"]"]
  ],
  propSources: [jsonHighlighting],
  skippedNodes: [0,1],
  repeatNodeCount: 2,
  tokenData: "/[~RlXY!yYZ!y]^!ypq!yrs#Ost%h|}&S}!O&X!Q!R&b!R!['p![!](R!c!d(W!e!f(i!f!g)^!g!h*S!h!i*q!i!j+T!k!l,o!q!r,u!u!v,{!x!y+m!}#O-X#P#Q-^#Y#Z-c#b#c.Q#h#i.i#o#p/Q#q#r/V~#OOf~~#RWpq#Oqr#Ors#ks#O#O#O#P#p#P;'S#O;'S;=`%b<%lO#O~#pOh~~#sXrs#O!P!Q#O#O#P#O#U#V#O#Y#Z#O#b#c#O#f#g#O#h#i#O#i#j$`~$cR!Q![$l!c!i$l#T#Z$l~$oR!Q![$x!c!i$x#T#Z$x~${R!Q![%U!c!i%U#T#Z%U~%XR!Q![#O!c!i#O#T#Z#O~%eP;=`<%l#O~%mTP~OY%hZ]%h^;'S%h;'S;=`%|<%lO%h~&PP;=`<%l%h~&XOk~~&[Q!Q!R&b!R!['p~&gRU~!O!P&p!g!h'U#X#Y'U~&sP!Q![&v~&{RU~!Q![&v!g!h'U#X#Y'U~'XR{|'b}!O'b!Q!['h~'eP!Q!['h~'mPU~!Q!['h~'uSU~!O!P&p!Q!['p!g!h'U#X#Y'U~(WOj~~(ZP!p!q(^~(aP!f!g(d~(iOa~~(lP!t!u(o~(rP!g!h(u~(xP!c!d({~)OP!v!w)R~)UP!g!h)X~)^O`~~)aP!k!l)d~)gP!u!v)j~)mP!r!s)p~)sP!n!o)v~)yP!c!d)|~*PP!{!|)X~*VP!p!q*Y~*]P!f!g*`~*eSa~!e!f(i!h!i*q!i!j+T!x!y+m~*tP!q!r*w~*zP!t!u*}~+QP!o!p)X~+WP!k!l+Z~+^P!x!y+a~+dP!g!h+g~+jP!p!q)X~+pP!c!d+s~+vP!n!o+y~+|P!k!l,P~,SP!f!g,V~,YP!c!d,]~,`P!v!w,c~,fP!k!l,i~,lP!q!r+g~,rP!h!i(d~,xP!t!u(d~-OP!g!h-R~-UP!v!w)X~-^O^~~-cO]~~-fP#T#U-i~-lP#`#a-o~-rP#g#h-u~-xP#X#Y-{~.QOS~~.TP#i#j.W~.ZP#`#a.^~.aP#`#a.d~.iOT~~.lP#f#g.o~.rP#i#j.u~.xP#X#Y.{~/QOR~~/VOX~~/[OW~",
  tokenizers: [0],
  topRules: {"JsonText":[0,2]},
  tokenPrec: 0
});

function indentBody(context, node) {
    let base = context.lineIndent(node.from);
    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;
    // Don't consider blank, deindented lines at the end of the
    // block part of the block
    if (!/\S/.test(line.text) &&
        context.node.to < to + 100 &&
        !/\S/.test(context.state.sliceDoc(to, context.node.to)) &&
        context.lineIndent(context.pos, -1) <= base)
        return null;
    // A normally deindenting keyword that appears at a higher
    // indentation than the block should probably be handled by the next
    // level
    if (/^\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)
        return null;
    return base + context.unit;
}
let parserWithMetadata = parser.configure({
    props: [
        indentNodeProp.add({
            Body: context => { var _a; return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue(); },
            IfStatement: cx => /^\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        }),
        foldNodeProp.add({ Application: foldInside }),
        styleTags({
            Identifier: tags.variableName,
            Boolean: tags.bool,
            String: tags.string,
            Comment: tags.comment,
            "( )": tags.paren
        }),
        // indentNodeProp.add({
        //     Application: context => context.column(context.node.from) + context.unit
        // })
    ]
});
const SEELanguage = LRLanguage.define({
    parser: parserWithMetadata,
    languageData: {
        commentTokens: { line: "#" },
        indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
    }
});
const completions = [
    { "label": "CREATE", "type": "function" },
    { "label": "FORM", "type": "keyword" },
    { "label": "ENDFORM", "type": "keyword" },
    { "label": "VALIDATION", "type": "keyword" },
    { "label": "GIVEN", "type": "keyword" },
    { "label": "ENDGIVEN", "type": "keyword" },
    { "label": "IF", "type": "bool" },
    { "label": "AND", "type": "bool" },
    { "label": "OR", "type": "bool" },
    { "label": "SET", "type": "keyword" },
    { "label": "DISPLAY", "type": "keyword" },
    { "label": "END", "type": "book" },
    { "label": "ENDVALIDATION", "type": "keyword" },
    { "label": "ENDCREATE", "type": "keyword" },
    { "label": "park", "type": "constant", "info": "Test completion" },
    { "label": "password", "type": "variable" }
];
const SEECompletion = SEELanguage.data.of({
    autocomplete: completeFromList(completions)
});
function SEE() {
    return new LanguageSupport(SEELanguage, [SEECompletion]);
}

export { SEE, SEECompletion, SEELanguage, completions, parserWithMetadata };
